

1. What the values in your table correspond to

	one table T[i]. T[i] stores the minimum number of coins required to amount to i.

2. The DP-Relation that computes one table entry in terms of other table entries

	T[i] = 1 + min{T[i-1], T[i-6], T[i-27], T[i-38], T[i-50]}

3. How would you initialize the table

	T[i < 0] = infinity (given)
	T[0] = 0
	
4. Which entry of the table you return at the end of the algorithm
	
	We return the last entry of T found at T[N]
	Along with T[n], we return an array A of size T[n] containing a sequence of coins that amount to N.
	
	We return a tuple (T[N], A)


5. pseudocode for the final algorithm

	T <- new array of size N + 1 // indexing goes from 0 through N
	T[0] = 0
	
	for i = 1 to N:
	    T[i] = 1 + min{T[i-1], T[i-6], T[i-27], T[i-38], T[i-50]}

	A = new array of size T[N]
	
	amt = N
	for i=0 to len(A) - 1:
	    j = min{T[amt-1], T[amt-6], T[amt-27], T[amt-38], T[amt-50]}
	    
	    if(j = T[amt-1])
	    	A[i] = 1
	    	amt -= 1
	    else if(j = T[amt-6])
	    	A[i] = 6
	    	amt -= 6
	    else if(j = T[amt-27])
	    	A[i] = 27
	    	amt -= 27
	    else if(j = T[amt-38])
	    	A[i] = 38
	    	amt -= 38
	    else if(j = T[amt-50])
	        A[i] = 50
	    	amt -= 50
	    	
	 
	 return (T[N], amt)
